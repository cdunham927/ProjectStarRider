// Spline Spawner by Staggart Creations (http://staggart.xyz)
// COPYRIGHT PROTECTED UNDER THE UNITY ASSET STORE EULA (https://unity.com/legal/as-terms)
//  • Copying or referencing source code for the production of new asset store, or public, content is strictly prohibited!
//  • Uploading this file to a public GitHub repository will subject it to an automated DMCA takedown request.

#pragma kernel RenderSDF
#pragma kernel SampleSDF

//Rasterized spline SDF
RWTexture2D<float> _SDF;

//Spline position samples
StructuredBuffer<float3> _SplinePoints;
StructuredBuffer<int2> _PositionIndices;

int _SplineCount;
float3 _AreaCenter;
float3 _AreaSize;
uint2 _Resolution;

float _Margin;
bool _UseFill;
bool _Invert;
half _CapBlend;
bool _IsClosedSpline;

//Input, world-space positions to sample at
StructuredBuffer<float3> _SamplePositions;
uint _SamplePositionCount;
//Spline SDF weight at positions
RWStructuredBuffer<float> _SampleResults;

float SignedDistanceLine(float2 p, float2 a, float2 b)
{
	float2 pa = p - a;
	float2 ba = b - a;
	
	float h = saturate(dot(pa, ba) / dot(ba, ba));
	return length(pa - ba * h);
}

// Winding number contribution from a single edge
int WindingContribution(float2 p, float2 a, float2 b)
{
	if (a.y <= p.y)
	{
		if (b.y > p.y && cross(float3(b - a, 0), float3(p - a, 0)).z > 0)
			return 1;
	}
	else
	{
		if (b.y <= p.y && cross(float3(b - a, 0), float3(p - a, 0)).z < 0)
			return -1;
	}
	return 0;
}

[numthreads(8,8,1)]
void RenderSDF (uint3 id : SV_DispatchThreadID)
{
	float minDist = 1e10;
	bool inside  = false;

	if (id.x >= _Resolution.x-2 || id.x == 0 || id.y == 0 || id.y > _Resolution.y-2)
	{
		_SDF[id.xy] = _Invert ? -minDist : minDist;
		return;
	}

	float2 uv = (float2(id.xy) + 0.5) / _Resolution.xy;
	float2 worldPos = _AreaCenter.xz + (uv - 0.5) * _AreaSize.xz;
	
	for (int splineIndex = 0; splineIndex < _SplineCount; splineIndex++)
	{
		int start = _PositionIndices[splineIndex].x;
		int end = _PositionIndices[splineIndex].y;
		
		int windingNumber = 0;
		inside = false;

		for (int i = start; i < end - 1; ++i)
		{
			//Line segment between samples
			float2 a = _SplinePoints[i].xz;
			float2 b = _SplinePoints[i + 1].xz;

			float2 closestPoint = a;

			//Line
			if(_UseFill == false && _IsClosedSpline == false)
			{
				float2 ab = b - a;
				float2 ap = worldPos - a;

				float t = dot(ap, ab) / dot(ab, ab); // projection param (0–1)

				float capBlendMin = -_CapBlend;
				float capBlendMax = 1.0 + _CapBlend;

				// If it's an end cap and outside the projection range, soften it based on cap blend
				bool isEndCap = (i == start || i == end - 2);
				if (isEndCap && (t < capBlendMin || t > capBlendMax))
					continue;

				// Compute capped version of t
				t = clamp(t, 0.0, 1.0);

				closestPoint = a + t * ab;
			}

			float rawDist = distance(worldPos, closestPoint);
			minDist = min(minDist, rawDist);
			
			if (_UseFill)
			{
				windingNumber += WindingContribution(worldPos, a, b);
				inside = (windingNumber != 0);
			}
		}

		if (_UseFill && inside)
		{
			minDist *= -1;
		}
	}

	minDist -= _Margin - 0.5;
	
	if (_Invert) minDist = -minDist;
	
	_SDF[id.xy] = minDist;
}

[numthreads(64,1,1)]
void SampleSDF(uint id : SV_DispatchThreadID)
{
	if (id >= _SamplePositionCount)
	{
		_SampleResults[id] = 0;
		return;
	}

	float3 worldPos = _SamplePositions[id];

	//Out of bounds
	if (worldPos.x > (_AreaCenter.x + _AreaSize.x) || worldPos.x < (_AreaCenter.x - _AreaSize.x) ||
		worldPos.z > (_AreaCenter.z + _AreaSize.z) || worldPos.z < (_AreaCenter.z - _AreaSize.z))
	{
		//Pretend the result is extremely far away, because this should not affect any spawn points
		_SampleResults[id] = 999999;
		return;
	}
        
	//Convert world position to local space relative to the area center
	float2 local = float2(worldPos.x - _AreaCenter.x, worldPos.z - _AreaCenter.z);

	//Normalize to [0, 1] range across the area
	float2 normalized = float2(
		(local.x + _AreaSize.x * 0.5f) / _AreaSize.x,
		(local.y + _AreaSize.z * 0.5f) / _AreaSize.z
	);

	int x = floor(normalized.x * _Resolution.x);
	int y = floor(normalized.y * _Resolution.y);

	x = clamp(x, 0, _Resolution.x - 1);
	y = clamp(y, 0, _Resolution.y - 1);

	float sdfSample = _SDF.Load(int2(x,y)).r;

	_SampleResults[id] = sdfSample;
}